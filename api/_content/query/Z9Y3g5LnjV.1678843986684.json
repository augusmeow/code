{"_path":"/cpp/thread-mutex/thread","_dir":"thread-mutex","_draft":false,"_partial":false,"_locale":"","_empty":false,"title":"Thread","description":"","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"thread"},"children":[{"type":"text","value":"Thread"}]},{"type":"element","tag":"h2","props":{"id":"在c标准中提供了-stdthread-stdasync-stdpackage_task-stdpromise等模块以支持异步开发-在实际开发中一般使用那种呢-还是直接使用pthread"},"children":[{"type":"text","value":"在c++标准中提供了 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::thread"}]},{"type":"text","value":", "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::async"}]},{"type":"text","value":", "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::package_task"}]},{"type":"text","value":", "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::promise"}]},{"type":"text","value":"等模块以支持异步开发, 在实际开发中一般使用那种呢, 还是直接使用pthread?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在实际开发中，使用哪种方法取决于应用程序的具体需求和限制。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::thread"}]},{"type":"text","value":" 是一个用于在c++程序中创建和管理线程的标准库类。使用"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::thread"}]},{"type":"text","value":"可以方便地在c++程序中创建线程，并且可以使用c++标准库的同步原语（如"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::mutex"}]},{"type":"text","value":"和"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::condition_variable"}]},{"type":"text","value":"）来管理线程间的同步。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::async"}]},{"type":"text","value":" 是一个用于在c++程序中执行异步操作的函数。"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::async"}]},{"type":"text","value":"可以在后台执行指定的任务，并返回一个 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::future"}]},{"type":"text","value":" 对象，可以用来获取任务的结果。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::package_task"}]},{"type":"text","value":" 是一个c++标准库类，用于封装异步任务。"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::package_task"}]},{"type":"text","value":" 可以用来封装任意可调用对象（如函数、lambda表达式等），然后可以在以后执行这个任务。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::promise"}]},{"type":"text","value":" 是一个c++标准库类，用于在线程之间传递结果值。"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::promise"}]},{"type":"text","value":" 可以用来向一个 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::future"}]},{"type":"text","value":" 对象写入结果值，以便在其他线程中获取该值。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在实际开发中，使用 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::thread"}]},{"type":"text","value":", "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::async"}]},{"type":"text","value":", "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::package_task"}]},{"type":"text","value":", "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::promise"}]},{"type":"text","value":" 等方法的选择取决于应用程序的具体需求和限制。例如，如果需要创建多个线程来执行异步任务，可以使用 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::thread"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::mutex"}]},{"type":"text","value":" 等同步原语来管理线程。如果需要在后台执行异步任务，并获取结果，可以使用 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::async"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::future"}]},{"type":"text","value":"。如果需要在以后执行异步任务，可以使用 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::package_task"}]},{"type":"text","value":" 封装任务，并在需要时执行。如果需要在线程之间传递结果值，可以使用 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::promise"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::future"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外，c++标准库中还提供了 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::thread::id"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::thread::native_handle"}]},{"type":"text","value":" 等类型，可以用来标识和操作线程。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果需要，也可以使用"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"pthread"}]},{"type":"text","value":"库来创建和管理线程。"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"pthread"}]},{"type":"text","value":"库是一个跨平台的库，用于在Linux、macOS和其他操作系统上创建和管理线程。使用"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"pthread"}]},{"type":"text","value":"库需要在c++程序中包含头文件"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"#include <pthread.h>"}]},{"type":"text","value":"，并使用pthread库提供的函数和数据类型来创建和管理线程。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"总的来说，在实际开发中，可以根据应用程序的具体需求和限制，选择使用c++标准库中提供的 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::thread"}]},{"type":"text","value":", "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::async"}]},{"type":"text","value":", "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::package_task"}]},{"type":"text","value":", "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"std::promise"}]},{"type":"text","value":" 等方法，或者使用"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"pthread"}]},{"type":"text","value":"库来创建和管理线程。使用c++标准库提供的方法可以保证程序的可移植性和可读性，同时也提供了丰富的同步原语和容器类型，可以方便地管理线程和数据。使用pthread库则可以提供更多的低级别控制，并可以在更多的平台上使用。"}]},{"type":"element","tag":"h2","props":{"id":"在多线程开发中-有没有什么好的编程模式或程序设计方法-能够尽可能的避免锁带来的性能消耗和死锁问题"},"children":[{"type":"text","value":"在多线程开发中, 有没有什么好的编程模式或程序设计方法, 能够尽可能的避免锁带来的性能消耗和死锁问题?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在多线程开发中, 一种常见的编程模式是使用锁的升级。在这种模式中, 在初始状态下, 线程以读写锁的形式访问共享资源。如果线程需要写入共享资源, 它会升级读写锁为互斥锁, 以保证其他线程不能访问共享资源。这样做可以避免许多线程同时写入共享资源, 从而减少锁竞争。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另一种常用的方法是使用无锁算法。这些算法通常通过原子操作和内存屏障来保证线程安全, 而无需使用锁。由于这些算法不使用锁, 它们通常比使用锁的算法更快, 并且不会导致死锁问题。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"总的来说, 最好的方法是根据具体情况来选择编程模式和程序设计方法, 以避免锁带来的性能消耗和死锁问题。"}]},{"type":"element","tag":"h2","props":{"id":"线程安全"},"children":[{"type":"text","value":"线程安全"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"关于全局变量/局部变量/静态变量的线程安全问题"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"在c标准中提供了-stdthread-stdasync-stdpackage_task-stdpromise等模块以支持异步开发-在实际开发中一般使用那种呢-还是直接使用pthread","depth":2,"text":"在c++标准中提供了 std::thread, std::async, std::package_task, std::promise等模块以支持异步开发, 在实际开发中一般使用那种呢, 还是直接使用pthread?"},{"id":"在多线程开发中-有没有什么好的编程模式或程序设计方法-能够尽可能的避免锁带来的性能消耗和死锁问题","depth":2,"text":"在多线程开发中, 有没有什么好的编程模式或程序设计方法, 能够尽可能的避免锁带来的性能消耗和死锁问题?"},{"id":"线程安全","depth":2,"text":"线程安全"}]}},"_type":"markdown","_id":"content:1.cpp:thread-mutex:thread.md","_source":"content","_file":"1.cpp/thread-mutex/thread.md","_extension":"md"}