{"_path":"/cpp/concept/stack_memory","_dir":"concept","_draft":false,"_partial":false,"_locale":"","_empty":false,"title":"堆栈 内存","description":"","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"堆栈-内存"},"children":[{"type":"text","value":"堆栈 内存"}]},{"type":"element","tag":"h2","props":{"id":"简述-c-的内存分区"},"children":[{"type":"text","value":"简述 C++ 的内存分区"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"C/C++内存存储区有哪几种类型？"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在C++中，内存被分为若干个不同的区域，分别用于存放不同类型的数据。这些内存区域包括："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"栈区：用于存放函数的局部变量和临时变量。栈区的内存空间是自动分配和释放的，由编译器自动管理。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"堆区：用于存放动态分配的内存空间。堆区的内存空间是需要手动分配和释放的，由程序员自己管理。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"静态存储区：用于存放全局变量和静态变量。静态存储区的内存空间在程序初始化时分配，在程序结束时释放。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"常量存储区：用于存放常量数据。常量存储区的内存空间在程序初始化时分配，在程序结束时释放。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"程序代码区：用于存放程序的可执行代码。程序代码区的内存空间在程序初始化时分配，在程序结束时释放。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"栈区和堆区是C++程序中最常用的内存区域。栈区用于存放函数的局部变量和临时变量，其内存空间是自动分配和释放的，由编译器自动管理。堆区用于存放动态分配的内存空间，其内存空间是需要手动分配和释放的，由程序员自己管理。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"例如，下面是一个使用栈区和堆区的示例程序："}]},{"type":"element","tag":"code","props":{"code":"#include <iostream>\n\nvoid func() {\n  int a = 5; // a 存放在栈区\n  std::cout << a << std::endl;\n}\n\nint main() {\n  int* p = new int(5); // p 存放在栈区，它所指向的内存空间存放在堆区\n  std::cout << *p << std::endl;\n  delete p;\n\n  func();\n\n  return 0;\n}\n","language":"cpp","meta":null},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"div","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"#include"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-1ca446"},"children":[{"type":"text","value":"<iostream>"}]}]},{"type":"element","tag":"div","props":{"class":"line"},"children":[]},{"type":"element","tag":"div","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"void"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-487821"},"children":[{"type":"text","value":"func"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"() {"}]}]},{"type":"element","tag":"div","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"  "}]},{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"int"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":" a "}]},{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"="}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-a5ba8d"},"children":[{"type":"text","value":"5"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":";"}]},{"type":"element","tag":"span","props":{"class":"ct-87ecfe"},"children":[{"type":"text","value":" // a 存放在栈区"}]}]},{"type":"element","tag":"div","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"  "}]},{"type":"element","tag":"span","props":{"class":"ct-54cfd6"},"children":[{"type":"text","value":"std"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"::cout "}]},{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"<<"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":" a "}]},{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"<<"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-54cfd6"},"children":[{"type":"text","value":"std"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"::endl;"}]}]},{"type":"element","tag":"div","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"}"}]}]},{"type":"element","tag":"div","props":{"class":"line"},"children":[]},{"type":"element","tag":"div","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"int"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-487821"},"children":[{"type":"text","value":"main"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"() {"}]}]},{"type":"element","tag":"div","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"  "}]},{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"int*"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":" p "}]},{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"="}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"new"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"int"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"("}]},{"type":"element","tag":"span","props":{"class":"ct-a5ba8d"},"children":[{"type":"text","value":"5"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":");"}]},{"type":"element","tag":"span","props":{"class":"ct-87ecfe"},"children":[{"type":"text","value":" // p 存放在栈区，它所指向的内存空间存放在堆区"}]}]},{"type":"element","tag":"div","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"  "}]},{"type":"element","tag":"span","props":{"class":"ct-54cfd6"},"children":[{"type":"text","value":"std"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"::cout "}]},{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"<<"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"*"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"p "}]},{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"<<"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-54cfd6"},"children":[{"type":"text","value":"std"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"::endl;"}]}]},{"type":"element","tag":"div","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"  "}]},{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"delete"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":" p;"}]}]},{"type":"element","tag":"div","props":{"class":"line"},"children":[]},{"type":"element","tag":"div","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"  "}]},{"type":"element","tag":"span","props":{"class":"ct-487821"},"children":[{"type":"text","value":"func"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"();"}]}]},{"type":"element","tag":"div","props":{"class":"line"},"children":[]},{"type":"element","tag":"div","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"  "}]},{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"return"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-a5ba8d"},"children":[{"type":"text","value":"0"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":";"}]}]},{"type":"element","tag":"div","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"}"}]}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在这个程序中，我们定义了一个函数func和一个主函数main。在函数func中，我们定义了一个局部变量a，它存放在栈区中。在主函数main中，我们定义了一个指针p，并使用动态内存分配运算符new为它分配了一个新的内存空间，并将值5赋值给它。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"根据这个程序的定义，我们可以得到以下的内存分配情况："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"变量a存放在栈区，它的生命周期与函数func相同。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"指针p存放在栈区，它所指向的内存空间存放在堆区，它的生命周期与主函数main相同。\n在这个程序中，变量a和指针p都是在函数调用时分配内存空间的，并在函数结束时释放内存空间。因此，它们的生命周期与函数的调用相关。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"总之，C++的内存分区是指将内存分为若干个不同的区域，分别用于存放不同类型的数据。这些内存区域包括栈区、堆区、静态存储区、常量存储区和程序代码区。C++程序中最常用的内存区域是栈区和堆区，它们分别用于存放函数的局部变量和动态分配的内存空间。"}]},{"type":"element","tag":"h2","props":{"id":"简述-c-中内存对齐的使用场景"},"children":[{"type":"text","value":"简述 C++ 中内存对齐的使用场景"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在C++中，内存对齐指的是将内存空间按照某种规则进行划分和排列，以提高内存访问的效率。内存对齐通常用于结构体和联合体，以减少内存碎片，提高内存利用率。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"例如，下面是一个使用内存对齐的示例程序："}]},{"type":"element","tag":"code","props":{"code":"#include <iostream>\n\nstruct S {\n  char c;\n  int i;\n  double d;\n} __attribute__((aligned(8)));\n\nint main() {\n  S s;\n  std::cout << sizeof(s) << std::endl;\n\n  return 0;\n}\n","language":"cpp","meta":null},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"div","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"#include"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-1ca446"},"children":[{"type":"text","value":"<iostream>"}]}]},{"type":"element","tag":"div","props":{"class":"line"},"children":[]},{"type":"element","tag":"div","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"struct"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-54cfd6"},"children":[{"type":"text","value":"S"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":" {"}]}]},{"type":"element","tag":"div","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"  "}]},{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"char"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":" c;"}]}]},{"type":"element","tag":"div","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"  "}]},{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"int"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":" i;"}]}]},{"type":"element","tag":"div","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"  "}]},{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"double"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":" d;"}]}]},{"type":"element","tag":"div","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"} "}]},{"type":"element","tag":"span","props":{"class":"ct-a5ba8d"},"children":[{"type":"text","value":"__attribute__((aligned(8)))"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":";"}]}]},{"type":"element","tag":"div","props":{"class":"line"},"children":[]},{"type":"element","tag":"div","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"int"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-487821"},"children":[{"type":"text","value":"main"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"() {"}]}]},{"type":"element","tag":"div","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"  S s;"}]}]},{"type":"element","tag":"div","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"  "}]},{"type":"element","tag":"span","props":{"class":"ct-54cfd6"},"children":[{"type":"text","value":"std"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"::cout "}]},{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"<<"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"sizeof"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"(s) "}]},{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"<<"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-54cfd6"},"children":[{"type":"text","value":"std"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"::endl;"}]}]},{"type":"element","tag":"div","props":{"class":"line"},"children":[]},{"type":"element","tag":"div","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"  "}]},{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"return"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-a5ba8d"},"children":[{"type":"text","value":"0"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":";"}]}]},{"type":"element","tag":"div","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"}"}]}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在这个程序中，我们定义了一个结构体S，并在定义的后面加上了一个属性说明符，指定结构体的内存对齐方式为8字节对齐。这意味着编译器会将结构体的内存空间按照8字节为单位进行划分和排列。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"由于结构体S中包含了3个成员，分别为一个字符、一个整型数和一个浮点数，它们的大小分别为1字节、4字节和8字节。根据内存对齐的规则，编译器会将这3个成员按照8字节为单位进行划分和排列，并将剩余的空间补齐为8字节的倍数。因此，结构体S的大小应该为24字节。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在这个程序的主函数中，我们定义了一个结构体变量s，并使用了sizeof运算符计算了它的大小。如果编译器支持内存对齐，那么程序的输出应该为24。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"总之，内存对齐是指将内存空间按照某种规则进行划分和排列，以提高内存访问的效率。内存对齐通常用于结构体和联合体，以减少内存碎片，提高内存利用率。使用内存对齐可以提高程序的性能和效率。"}]},{"type":"element","tag":"h2","props":{"id":"c-是如何进行内存管理的"},"children":[{"type":"text","value":"C++ 是如何进行内存管理的？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"提供了一些与内存管理相关的关键字和操作符，用于帮助程序员在程序中合理地分配和释放内存。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"关键字new用于在堆上分配内存，并返回指向该内存区域的指针。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"关键字delete用于释放由new关键字分配的内存。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"运算符new"},{"type":"element","tag":"span","props":{},"children":[]},{"type":"text","value":"用于在堆上分配数组，并返回指向该数组的指针。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"运算符delete"},{"type":"element","tag":"span","props":{},"children":[]},{"type":"text","value":"用于释放由new"},{"type":"element","tag":"span","props":{},"children":[]},{"type":"text","value":"运算符分配的数组。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"例如，下面的代码演示了如何在堆上分配内存，并使用delete关键字释放该内存："}]},{"type":"element","tag":"code","props":{"code":"int *p = new int;   // 分配一个int型变量的内存\n*p = 100;           // 通过指针p访问该内存并赋值\ndelete p;           // 释放内存\n","language":"cpp","meta":null},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"div","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"int"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"*"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"p "}]},{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"="}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"new"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"int"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":";"}]},{"type":"element","tag":"span","props":{"class":"ct-87ecfe"},"children":[{"type":"text","value":"   // 分配一个int型变量的内存"}]}]},{"type":"element","tag":"div","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"*"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":"p "}]},{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"="}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-a5ba8d"},"children":[{"type":"text","value":"100"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":";"}]},{"type":"element","tag":"span","props":{"class":"ct-87ecfe"},"children":[{"type":"text","value":"           // 通过指针p访问该内存并赋值"}]}]},{"type":"element","tag":"div","props":{"class":"line"},"children":[{"type":"element","tag":"span","props":{"class":"ct-ca1850"},"children":[{"type":"text","value":"delete"}]},{"type":"element","tag":"span","props":{"class":"ct-e8033c"},"children":[{"type":"text","value":" p;"}]},{"type":"element","tag":"span","props":{"class":"ct-87ecfe"},"children":[{"type":"text","value":"           // 释放内存"}]}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"需要注意的是，如果程序员忘记使用delete关键字释放内存，可能会造成内存泄露，即内存无法被释放而被浪费。因此，程序员应该认真跟踪内存分配并在适当的时候使用delete关键字释放内存。"}]},{"type":"element","tag":"h2","props":{"id":"内存中堆与栈的区别是什么"},"children":[{"type":"text","value":"内存中堆与栈的区别是什么？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"堆和栈是内存中两种不同的存储区域，它们各有特点，并在程序执行中扮演不同的角色。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"栈是一种后进先出（LIFO）的内存结构，由编译器自动分配和释放。栈中的变量通常是局部变量，它们在函数调用结束时自动释放。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"堆是一种动态分配内存的方式，由程序员控制内存的分配和释放。堆中的变量通常是全局变量或者是动态分配的内存，它们在程序结束前一直保存在内存中。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因此，栈和堆最大的区别在于分配和释放方式不同。栈中的变量是由编译器自动分配释放的，而堆中的变量是由程序员手动分配释放的。另外，栈中的变量一般是局部变量，堆中的变量一般是全局变量或者是动态分配的内存。"}]},{"type":"element","tag":"h2","props":{"id":"内存的分配方式有几种"},"children":[{"type":"text","value":"内存的分配方式有几种"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。"}]}]},{"type":"element","tag":"h2","props":{"id":"c如何避免内存泄漏"},"children":[{"type":"text","value":"C++如何避免内存泄漏"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这其实可以看做是一个编程风格的问题。"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用RAII(Resource Acquisition Is Initialization,资源获取即初始化)技法，以构造函数获取资源(内存),析构函数释放。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"相比于使用原生指针，更建议使用智能指针，尤其是C++11标准化后的智能指针。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"注意delete和delete"},{"type":"element","tag":"span","props":{},"children":[]},{"type":"text","value":"的使用方法。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"这是很复杂的一种情况，是关于类的copy constructor的。首先先介绍一些概念。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"同default constructor一样，标准保证，如果类作者没有为class声明一个copy constructor，那么编译器会在需要的时候产生出来(这也是一个常考点：问道”如果类作者未定义出default/copy\nconstructor，编译器会自动产生一个吗？”答案是否定的)\n不过请注意！！这里编译器即使产生出来，也是为满足它的需求，而非类作者的需求！！\n而什么时候是编译器”需要”的时候呢？是在当这个class 【不表现出】bitwise copy semantics(位逐次拷贝，即浅拷贝)\n的时候。 在4中情况下class【不表现出】bitwise copy semantics"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"当class内含一个member object且该member object声明了一个copy constructor(无论该copy ctor是类作者自己生明的还是编译器合成的)；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"当class继承自一个base class且该base class有一个copy constructor(无论该copy ctor是类作者自己生明的还是编译器合成的)；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"当class声明了virtual function；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"当class派生自一个继承链，且该链中存在virtual base class时。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"言归正传，如果class中仅仅是一些普通资源，那么default memberwise copy是完全够用的；然而，挡在该class中存在了一块动态分配的内存，并且在之后执行了bitwise copy\nsemantics后，将会有一个按位拷贝的对象和原来class中的某个成员指向同一块heap空间，当执行它们的析构函数后，该内存将被释放两次，这是未定义的行为。因此，在必要的时候需要使用user###defined explicit\ncopy constructor，来避免内存泄露。"}]},{"type":"element","tag":"style","children":[{"type":"text","value":".ct-54cfd6{color:#953800}\n.ct-87ecfe{color:#6E7781}\n.ct-a5ba8d{color:#0550AE}\n.ct-487821{color:#8250DF}\n.ct-1ca446{color:#0A3069}\n.ct-e8033c{color:#24292F}\n.ct-ca1850{color:#CF222E}\n.dark .ct-ca1850{color:#FF7B72}\n.dark .ct-e8033c{color:#C9D1D9}\n.dark .ct-1ca446{color:#A5D6FF}\n.dark .ct-487821{color:#D2A8FF}\n.dark .ct-a5ba8d{color:#79C0FF}\n.dark .ct-87ecfe{color:#8B949E}\n.dark .ct-54cfd6{color:#FFA657}"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"简述-c-的内存分区","depth":2,"text":"简述 C++ 的内存分区"},{"id":"简述-c-中内存对齐的使用场景","depth":2,"text":"简述 C++ 中内存对齐的使用场景"},{"id":"c-是如何进行内存管理的","depth":2,"text":"C++ 是如何进行内存管理的？"},{"id":"内存中堆与栈的区别是什么","depth":2,"text":"内存中堆与栈的区别是什么？"},{"id":"内存的分配方式有几种","depth":2,"text":"内存的分配方式有几种"},{"id":"c如何避免内存泄漏","depth":2,"text":"C++如何避免内存泄漏"}]}},"_type":"markdown","_id":"content:1.cpp:concept:stack_memory.md","_source":"content","_file":"1.cpp/concept/stack_memory.md","_extension":"md"}