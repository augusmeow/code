{"_path":"/cpp/concept/diff","_dir":"concept","_draft":false,"_partial":false,"_locale":"","_empty":false,"title":"概念辨析","description":"","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"概念辨析"},"children":[{"type":"text","value":"概念辨析"}]},{"type":"element","tag":"h2","props":{"id":"struct-和-class-的区别"},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"struct"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"class"}]},{"type":"text","value":" 的区别"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"struct 是值类型，class 是对象类型"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"struct 不能被继承，class 可以被继承"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"struct 默认的访问权限是 public, 而 class 默认的访问权限是 private."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"struct 总是有默认的构造函数，即使是重载默认构造函数仍然会保留。这是因为 struct 的构造函数是由编译器自动生成的，但是如果重载构造函数，必需对 struct 中的变量全部初始化。并且 struct 的用途是那些描述轻量级的对象，例如 Line, Point 等，并且效率比较高。class 在没有重载构造函数时有默认的无参数构造函数，但是一被重载些默认构造函数将被覆盖。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"struct 的 new 和 class 的 new 是不同的。struct的new就是执行一下构造函数创建一个新实例再对所有的字段进行Copy。而class则是在堆上分配一块内存然后再执行构造函数，struct的内存并不是在new的时候分配的，而是在定义的时候分配"}]}]},{"type":"element","tag":"h2","props":{"id":"new和malloc的区别"},"children":[{"type":"text","value":"new和malloc的区别"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"new从自由存储区上分配内存，malloc从堆上分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配。那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"new、delete 返回的是某种数据类型指针；malloc、free 返回的是 void 指针。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算；使用malloc则需要显式地指出所需内存的尺寸。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"new 可以调用对象的构造函数，对应的 delete 调用相应的析构函数；malloc 仅仅分配内存，free 仅仅回收内存，并不执行构造和析构函数。在new一个对象的时候，首先会调用malloc为对象分配内存空间，然后调用对象的构造函数。delete会调用对象的析构函数，然后调用free回收内存。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"new、delete 是操作符，可以重载；malloc、free 是函数，可以重写(覆盖)。"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"struct-和-class-的区别","depth":2,"text":"struct 和 class 的区别"},{"id":"new和malloc的区别","depth":2,"text":"new和malloc的区别"}]}},"_type":"markdown","_id":"content:1.cpp:concept:diff.md","_source":"content","_file":"1.cpp/concept/diff.md","_extension":"md"}