{"_path":"/interview/compile","_dir":"interview","_draft":false,"_partial":false,"_locale":"","_empty":false,"title":"编译","description":"","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"编译"},"children":[{"type":"text","value":"编译"}]},{"type":"element","tag":"h2","props":{"id":"cc-编译时和运行时的内存区域分配"},"children":[{"type":"text","value":"c/c++ 编译时和运行时的内存区域分配"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"先来说下c程序编译内存分配："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"栈区(stack)：存放局部变量和参数，申请和释放都由编译器自动完成。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"堆区(heap)：动态内存分配，申请和释放都是由程序员控制。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"静态区/全局区(static)：存放全局变量和静态变量。下面存放了未初始化的静态/全局变量。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"文字常量区：存放字符串常量的。比如，char *p = “my name is”。“my....is!”字符串常量就存放那个区域。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"代码区(code)：用来存放代码的。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第二种是程序在运行时内存分配，程序在进程中的内存分配区域。\n从高地址到地址：\n1.环境变量(Unix/Linux中全局环境变量)\n2.stack区，存放内容和上文同。\n3.heap区，存放内容和上文同。值得说明的是：stack区起始地址是在高地址，即是从高地址向低地址延伸。而heap区起始地址是在低地址，即是从低地址向高地址延伸。总结：stack起始地址固定在高地址，heap起始地址固定在低地址，然后两个区都向中间延伸。直到stack区和heap区的结束地址重合则表示没有stack和heap内存空间了。\n4.data区，分为bss未初始化的数据区和初始化的数据区。\n5.文本(text)区，存放代码的区域。"}]},{"type":"element","tag":"h3","props":{"id":"编译时与运行时的内存情况"},"children":[{"type":"text","value":"编译时与运行时的内存情况"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1.编译时不分配内存"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n编译时是不分配内存的。此时只是根据声明时的类型进行占位，到以后程序执行时分配内存才会正确。所以声明是给编译器看的，聪明的编译器能根据声明帮你识别错误。\n2.运行时必分配内存"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n运行时程序是必须调到“内存”的。因为CPU（其中有多个寄存器）只与内存打交道的。程序在进入实际内存之前要首先分配物理内存。\n3.编译过程"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n只能简单说一下，因为如果要详细的话，就是一本书了《编译原理》。编译器能够识别语法，数据类型等等。然后逐行逐句检查编译成二进制数据的obj文件，然后再由链接程序将其链接成一个EXE文件。此时的程序是以EXE文件的形式存放在磁盘上。\n4.运行过程"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n当执行这个EXE文件以后，此程序就被加载到内存中，成为进程。此时一开始程序会初始化一些全局对象，然后找到入口函数（main()或者WinMain()），就开始按程序的执行语句开始执行。此时需要的内存只能在程序的堆上进行动态增加/释放了。"}]},{"type":"element","tag":"h2","props":{"id":"c-编译流程"},"children":[{"type":"text","value":"c++ 编译流程"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"cc-编译时和运行时的内存区域分配","depth":2,"text":"c/c++ 编译时和运行时的内存区域分配","children":[{"id":"编译时与运行时的内存情况","depth":3,"text":"编译时与运行时的内存情况"}]},{"id":"c-编译流程","depth":2,"text":"c++ 编译流程"}]}},"_type":"markdown","_id":"content:4.interview:compile.md","_source":"content","_file":"4.interview/compile.md","_extension":"md"}